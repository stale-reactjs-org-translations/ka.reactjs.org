---
id: rendering-elements
title: Rendering Elements
permalink: docs/rendering-elements.html
redirect_from:
  - "docs/displaying-data.html"
prev: introducing-jsx.html
next: components-and-props.html
---

ელემენტები React-აპლიკაციის უმცირესი შემადგენელი ნაწილები არიან.

ელემენტი იმის აღწერაა, რაც გსურთ რომ ეკრანზე გამოჩნდეს:

```js
const element = <h1>Hello, world</h1>;
```

ბრაუზერის DOM-ის ელემენტებისაგან განსხვავებით, React-ელემენტები არიან ჩვეულებრივი ობიექტები, და მათი შექმნა არ მოითხოვს დიდ რესურსს. React DOM უზრუნველყოფს ბრაუზერის DOM-ის განახლებას, მისი სრული შესაბამისობა რომ იყოს React-ელემენტებთან.

>**შენიშვნა:**
>
>ზოგს შესაძლოა ელემენტები აერიოს უფრო გავრცელებულ კონცეპტში - "კომპონენტები". კომპონენტებს ჩვენ [შემდგომ სექციაში](/docs/components-and-props.html) გავეცნობით. ელემენტები - ეს არის ის, რისგანაც კომპონენტები "არიან შედგენილნი" და, გირჩევთ, ჯერ ეს სექცია წაიკითხოთ, სანამ შემდგომზე გადახვალთ.

## ელემენტის გარენდერება DOM-ში {#rendering-an-element-into-the-dom}

ვთქვათ, თქვენს HTML ფაილში არის `<div>`:

```html
<div id="root"></div>
```

ჩვენ ვუწოდებთ ამ `<div>`-ს "მთავარ" DOM node-ს, რადგან ნებისმიერი მის შიგნით მოქცეული რამ იმართება React DOM-ის მიერ.

აპლიკაციას, რომელიც აგებულია მხოლოდ React-ის გამოყენებით, როგორც წესი, აქვს მხოლოდ ერთი მთავარი DOM node. თუ თქვენ აინტეგრირებთ React-ს უკვე აწყობილ აპლიკაციაში, შეგიძლიათ გქონდეთ რამდენიც გნებავთ, იმდენი იზოლირებული "მთავარი" DOM node.

React-ელემენტის მთავარ DOM node-ში გასარენდერებლად `ReactDOM.render()`-ს არგუმენტებად უნდა გადასცეთ ორივე, React-ელემენტიც და მთავარი DOM node-იც:

`embed:rendering-elements/render-an-element.js`

[](codepen://rendering-elements/render-an-element)

ამ მაგალითს გამოაქვს "Hello, world".

## გარენდერებული ელემენტის განახლება {#updating-the-rendered-element}

React-ელემენტები არიან [უცვლელნი](https://en.wikipedia.org/wiki/Immutable_object). შეუძლებელია ერთხელ შექმნილი ელემენტის children-ის ან ატრიბუტების შეცვლა. ელემენტი გავს ფილმის კადრს: იგი გამოხატავს UI-ის მდგომარეობას დროის რომელიღაც კონკრეტულ მომენტში.

ჩვენი ახლანდელი ცოდნის გათვალისწინებით, UI-ის განახლების ერთადერთი გზა არის ახალი ელემენტის შექმნა და `ReactDOM.render()`-ისათვის არგუმენტად გადაცემა.

დაუკვირდით საათის მაგალითს:

`embed:rendering-elements/update-rendered-element.js`

[](codepen://rendering-elements/update-rendered-element)

ამ მაგალითში `ReactDOM.render()` გამოიძახება [`setInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval)-ის ქოლბექიდან ყოველ წამში ერთხელ.

>**შენიშვნა:**
>
>პრაქტიკაში, React-აპლიკაციების უმეტესობა `ReactDOM.render()`-ს იძახებს მხოლოდ ერთხელ. შემდგომ სექციებში ვისწავლით, თუ როგორ უნდა განვაახლოთ ინტერფეისი [სტეიტიანი კომპონენტების](/docs/state-and-lifecycle.html) მეშვეობით.
>
>გირჩევთ, არ გამოტოვოთ არცერთი თავი, რადგან ყოველი შემდგომი თავი წარმოადგენს წინას გაგრძელებას.

## React ანახლებს მხოლოდ იმას, რისი განახლებაც აუცილებელია {#react-only-updates-whats-necessary}

React DOM ადარებს ელემენტს და მის children-ს წინა ვერსიასთან და ბრაუზერის DOM-ში შეაქვს მხოლოდ ის ცვლილებები, რაც აუცილებელია DOM-ის სასურველ მდგომარეობაში მოსაყვანად.

შეგიძლიათ შეამოწმოთ [ბოლო მაგალითი](codepen://rendering-elements/update-rendered-element) ბრაუზერის developer tools-ის მეშვეობით:

![DOM inspector showing granular updates](../images/docs/granular-dom-updates.gif)

მიუხედავად იმისა, რომ შევქმენით ელემენტი, რომელიც ყოველწამიერად აღწერს ინტერფეისის მთლიან სტრუქტურას, მხოლოდ ის node ნახლდება React DOM-ის მიერ, რომლის შიგთავსიც შეიცვალა.

უფრო ადვილია იფიქრო იმაზე, თუ როგორ უნდა გამოიყურებოდეს UI რომელიმე მოცემულ მომენტში, ვიდრე იფიქრო იმაზე, თუ როგორ შეცვალო UI დროის თითოეულ მომენტში. ჩვენი გამოცდილებით, ასეთი მიდგომა მთელი რიგი შეცდომების თავიდან არიდებაში გვეხმარება.
