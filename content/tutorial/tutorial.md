---
id: tutorial
title: "გაკვეთილი: შესავალი React-ში"
layout: tutorial
sectionid: tutorial
permalink: tutorial/tutorial.html
redirect_from:
  - "docs/tutorial.html"
  - "docs/why-react.html"
  - "docs/tutorial-ja-JP.html"
  - "docs/tutorial-ko-KR.html"
  - "docs/tutorial-zh-CN.html"
---

ეს სახელმძღვანელო არ მოითხოვს React-ის არანაირ (არსებულ) ცოდნას. 

## ვიდრე საქმეს შევუდგებოდეთ {#before-we-start-the-tutorial}

ამ პრაქტიკული სამუშაოს მიმდინარეობისას შევქმნით პატარა თამაშს. **თქვენ შესაძლოა მოგინდეთ ამ პრაქტიკული სამუშაოს გამოტოვება, რადგან, შესაძლოა მომავალში არ აპირებთ თამაშების შექმნას, მაგრამ, უმჯობესია არ გამოტოვოთ.** მიდგომები, რომლებსაც ამ სახელმძღვანელოდან შეიმეცნებთ, ფუნდამენტურია ნებისმიერი React აპლიკაციისათვის და მათი დაუფლება გაგიმარტივებთ React-ის სიღრმისეულად გააზრებას.

>რჩევა
>
>ეს სახელმძღვანელო განკუთვნილია მათთვის, ვინც ამჯობინებს, **ისწავლოს კეთებით**. თუ ამჯობინებთ, რომ ცნებები მიყოლებით შეისწავლოთ, გამოიყენეთ ჩვენი [ეტაპობრივი სახელმძღვანელო](/docs/hello-world.html). შეიძლება ითქვას, რომ პრაქტიკული სამუშაო და ეტაპობრივი სახელმძღვანელო ერთმანეთს ავსებენ.

სახელმძღვანელო დაყოფილია რამდენიმე განყოფილებად:

* [გარემოს მოწყობა](#setup-for-the-tutorial) დაგეხმარებათ, მიიღოთ **საწყისი პოზიცია**, რათა მიჰყვეთ შემდგომ მითითებებს.
* [მიმოხილვა](#overview) შეგასწავლით React-ის **ფუნდამენტურ საკითხებს**, როგორებიცაა: კომპონენტები, თვისებები და მდგომარეობა.
* [თამაშზე მუშაობის დასასრული](#completing-the-game) შეგასწავლით React-ზე კოდის წერისას **ყველაზე ხშირად გამოყენებულ მიდგომებს**.
* [დროში მოგზაურობის დამატება](#adding-time-travel) უფრო **მკაფიოდ დაგანახებთ** React-ის უნიკალურ ძლიერ მხარეებს.

ამ სახელმძღვანელოდან სარგებლის მისაღებად ყველა განყოფილების ერთბაშად გავლა არ არის აუცილებელი. ეცადეთ გაიაროთ იმდენი, რამდენსაც შეძლებთ, თუნდაც ეს იყოს ერთი ან ორი განყოფილება.

### რას ვქმნით? {#what-are-we-building}

ამ სახელმძღვანელოში გაჩვენებთ, როგორ შექმნათ ინტერაქტიული თამაში - ჯვრები და ნულები React-ის გამოყენებით. 

თქვენ შეგიძლიათ იხილოთ, თუ რის შექმნას ვაპირებთ: **[საბოლოო შედეგი](https://codepen.io/gaearon/pen/gWWZgR?editors=0010)**. თუ ვერ ჩაწვდით კოდის შინაარსს, ან, თუ თქვენთვის კოდის სინტაქსი არ არის ნაცნობი, არ იდარდოთ! სახელმძღვანელოს მიზანი არის ის, რომ დაგეხმაროთ React-ისა და მისი სინტაქსის შეცნობაში.

გირჩევთ, ვიდრე პრაქტიკულ მუშაობას შეუდგებით, ნახოთ თამაში - ჯვრები და ნულების საბოლოო ვარიანტი. ერთ-ერთი მთავარი მახასიათებელი, რომელიც უნდა გაითვალისწინოთ, არის სათამაშო სივრცის მარჯვენა მხარეს არსებული დანომრილი სია. ეს სია შეიცავს ისტორიას ყველა იმ სვლისა, რომელიც განხორციელდა თამაშის განმავლობაში, ხოლო მისი განახლება ხდება თამაშის მიმდინარეობისას.

როცა თამაში - ჯვრები და ნულების საბოლოო ვერსიას გაეცნობით, შეგიძლიათ, დახუროთ. ჩვენ დავიწყებთ უფრო მარტივი ნიმუშით. ჩვენი შემდეგი ნაბიჯია გარემოს მომზადება თამაშის შექმნის პროცესის დასაწყებად.

### წინაპირობები {#prerequisites}

ჩვენ ვვარაუდობთ, რომ თქვენთვის ნაცნობია HTML და JavaScript, მაგრამ, თქვენ შეძლებთ, მიყვეთ სახელმძღვანელოს იმ შემთხვევაშიც, თუ თქვენ იცით რომელიმე სხვა პროგრამირების ენა. ჩვენ ასევე ვვარაუდობთ, რომ თქვენთვის ნაცნობია პროგრამირების ცნებები, როგორებიცაა: ფუნქციები, ობიექტები, მასივები და, თუნდაც მცირედით - კლასები. 

თუ აპირებთ, რომ გადახედოთ JavaScript-ის საფუძვლებს, ჩვენ რეკომენდაციას ვუწევთ [ამ გზამკვლევს](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript). გაითვალისწინეთ, რომ ჩვენ ასევე გამოვიყენებთ ES6-ის (JavaScript-ის უახლესი ვერსია) ზოგიერთ თვისებებს, როგორებიცაა [ისარ-ფუნქციები](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), [კლასები](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) და [`const`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const). შეგიძლიათ გამოიყენოთ [Babel REPL](babel://es5-syntax-example), რათა იხილოთ, თუ როგორ გამოიყურება ES6 კოდი კომპილაციის შემდეგ.

## გარემოს მოწყობა {#setup-for-the-tutorial}

ამ სახელმძღვანელოთი სარგებლობის ორი გზა არსებობს: წეროთ კოდი თქვენს ბრაუზერში, ან მოაწყოთ ლოკალური დეველოპმენტის გარემო თქვენს კომპიუტერში.

### ვარიანტი 1: კოდის წერა ბრაუზერში {#setup-option-1-write-code-in-the-browser}

ეს უსწრაფესი გზაა დასაწყებას! 

პირველ რიგში, გახსენით ეს **[საწყისი კოდი](https://codepen.io/gaearon/pen/oWWQNa?editors=0010)** ახალ ჩანართში. თქვენ დაინახავთ თამაში - ჯვრები და ნულების ცარიელ ცხრილს და React-ის კოდს. პრაქტიკული სამუშაოს განმავლობაში სწორედ ამ კოდის რედაქტირებას მოვახდენთ.

შეგიძლიათ გამოტოვოთ გარემოს მოწყობის მეორე ვარიანტი და გადახვიდეთ React-ის [მიმოხილვაზე](#overview).

### ვარიანტი 2: ლოკალური დეველოპმენტის გარემო {#setup-option-2-local-development-environment}

ეს არის არჩევითი და არასავალდებულო ამ პრაქტიკული სამუშაოსთვის!

<br>

<details>

<summary><b>არასავალდებულო: ინსტრუქციები, რომლებიც დაგეხმარებათ, შეძლოთ თქვენი რჩეული ტექსტური რედაქტორის გამოყენება პრაქტიკული მუშაობის განმავლობაში</b></summary>

ეს არის უფრო შრომატევადი გზა, მაგრამ, ამ გზით შეძლებთ, პრაქტიკული მუშაობისას გამოიყენოთ თქვენი რჩეული რედაქტორი. აი, რა უნდა გააკეთოთ:

1. დარწმუნდით, რომ თქვენს მოწყობილობაზე დაყენებულია [Node.js](https://nodejs.org/en/)-ის უახლესი ვერსია.
2. მიყევით [Create React App-ის დაყენების ინსტრუქციას](/docs/create-a-new-react-app.html#create-react-app), რათა შექმნათ ახალი პროექტი.

```bash
npx create-react-app my-app
```

3. წაშალეთ ახალი პროექტის `src/` საქაღალდეში არსებული ყველა ფაილი

>შენიშვნა:
>
>**არ წაშალოთ `src` საქაღალდე მთლიანად, წაშალეთ მხოლოდ მასში არსებული ფაილები.** ჩვენ ამ ფაილებს ჩვენი პროექტისთვის შესაბამისი ფაილებით ჩავანაცვლებთ.

```bash
cd my-app
cd src

# თუ თქვენ იყენებთ Mac-ს ან Linux-ს:
rm -f *

# ან, თუ Windows-ს იყენებთ:
del *

# შემდეგ დაბრუნდით უკან, პროექტის საქაღალდეში:
cd ..
```

4. `src/` საქაღალდეში შექმენით `index.css` ფაილი და ჩაწერეთ მასში [ეს CSS კოდი](https://codepen.io/gaearon/pen/oWWQNa?editors=0100).

5. `src/` საქაღალდეში შექმენით `index.js` ფაილი და ჩაწერეთ მასში [ეს JS კოდი](https://codepen.io/gaearon/pen/oWWQNa?editors=0010).

6. `src/` საქაღალდეში არსებულ `index.js` ფაილის თავში (ზემოთ), დაამატეთ ეს სამი ხაზი:

```js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
```

ამის შემდეგ, თუ თქვენ გაუშვებთ `npm start` ბრძანებას პროექტის საქაღალდეში და ბრაუზერში გახსნით `http://localhost:3000` მისამართს, თქვენ უნდა დაინახოთ თამაში - ჯვრები და ნულების ცარიელი ცხრილი.

ჩვენ გირჩევთ, მიყვეთ [ამ ინსტრუქციებს](https://babeljs.io/docs/editors/), რათა მოახდინოთ სინტაქსის ხაზგასმის რეგულირება თქვენი რედაქტორისათვის.

</details>

### დამეხმარეთ, გავიჭედე! {#help-im-stuck}

თუ თქვენ გაიჭედეთ, გთხოვთ, შეამოწმეთ [საზოგადოების მხარდაჭერის წყაროები](/community/support.html). განსაკუთრებით, [ჩათი Reactiflux](https://discord.gg/reactiflux) არის დიდებული გზა დახმარების უსწრაფესად მიღებისთვის. თუ პასუხს ვერ მიიღებთ, ან, თუ ვერ დაგეხმარებიან, გთხოვთ, [განაცხადეთ ჩვენთან](https://github.com/reactjs/ru.reactjs.org/issues/new) და ჩვენ დაგეხმარებით.

## მიმოხილვა {#overview}

ახლა, როცა ყველაფერი მოვამზადეთ, მოდით, მიმოვიხილოთ React!

### რა არის React? {#what-is-react}

React არის დეკლარაციაული, ეფექტური და მოქნილი JavaScript-ის ბიბლიოთეკა მომხმარებლის ინტერფეისების შესაქმნელად. ის საშუალებას გაძლევთ, შეადგინოთ რთული UI-ს სტრუქტურა პატარა, განცალკევებული კოდის ნაწილებისაგან, - „კომპონენტებისაგან“.

React-ში გვაქვს რამდენიმე, ერთმანეთისაგან განსხვავებული სახის კომპონენტები, მაგრამ, ჩვენ დავიწყებთ `React.Component`-ის ქვეკლასებით: 

```javascript
class ShoppingList extends React.Component {
  render() {
    return (
      <div className="shopping-list">
        <h1>საყიდლების სია {this.props.name}-სათვის</h1>
        <ul>
          <li>Instagram</li>
          <li>WhatsApp</li>
          <li>Oculus</li>
        </ul>
      </div>
    );
  }
}

// გამოყენების მაგალითი: <ShoppingList name="მარკი" />
```

ჩვენ ისევ მივუბრუნდებით ამ სახალისო, XML-ის მსგავს ტეგებს. კომპონენტების გამოყენებით ჩვენ ვეუბნებით React-ს, თუ რისი დანახვა გვინდა ეკრანზე. როცა მონაცემები იცვლება, React ეფექტურად ანახლებს და ხელახლა ასახავს ჩვენს კომპონენტებს.

*ShoppingList* არის **React-ის კლასური კომპონენტის** მაგალითი. კომპონენტს გადაეცემა პარამეტრები, რომლებსაც ეწოდება - `props` (`properties`-ის, ანუ *თვისებების* შემოკლებული ვარიანტი), და შედეგად აბრუნებს ვიზუალურ იერარქიას `render` მეთოდის გამოყენებით.

`render` მეთოდი აბრუნებს იმის *აღწერას*, თუ რისი ნახვა გვინდა ეკრანზე. React იღებს ამ აღწერას და გვიჩვენებს ვიზუალურ შედეგს. უფრო კონკრეტულად, `render` აბრუნებს **React-ის ელემენტს**, რომელიც არის მსუბუქი აღწერა იმისა, თუ რისი ასახვა გვსურს. React დეველოპერების უმეტესობა იყენებს სპეციალურ სინტაქსს, ეგრედ წოდებულ "JSX"-ს, რომელიც ამ სტრუქტურების აგებას ამარტივებს. კომპილირების მომენტში, `<div />` გარდაიქმნება - `React.createElement('div')`-ად. ზემოთ მოცემული მაგალითი იგივეა, რაც:

```javascript
return React.createElement('div', {className: 'shopping-list'},
  React.createElement('h1', /* ... h1-ის შვილობილები ... */),
  React.createElement('ul', /* ... ul-ის შვილობილები ... */)
);
```

[იხილეთ სრული ვერსია.](babel://tutorial-expanded-version)

თუ დაინტერესდებით, `createElement()` დეტალურად არის განხილული [API სქოლიო](/docs/react-api.html#createelement)-ში, მაგრამ, ამ პრაქტიკულ სახელმძღვანელოში მას აღარ გამოვიყენებთ. მის ნაცვლად გავაგრძელებთ JSX-ის გამოყენებას.

JSX აღჭურვილია JavaScript-ის სრული ძალით. JSX-ში, ფიგურილ ფრჩხილებს შორის, შეგიძლიათ გამოიყენოთ *ნებისმიერი* JavaScript გამოსახულება. React-ის ყოველი ელემენტი არის JavaScript-ის ობიექტი, რომელიც, შეგიძლიათ შეინახოთ ცვლადში, ან გაავრცელოთ თქვენი აპლიკაციის ფარგლებში.

ზემოთ მოცემული `ShoppingList` კომპონენტი მხოლოდ DOM-ში ჩაშენებულ კომპონენტებს გამოსახავს, როგორებიცაა `<div />` და `<li />`. მაგრამ, ასევე შეგვიძლია, გამოვსახოთ ჩვენს მიერ შექმნილი კომპონენტებიც. მაგალითად, ახლა შეგვიძლია გამოვსახოთ საყიდლების სია `<ShoppingList />`-ის დაწერით. React-ის ყოველი კომპონენტი ინკაფსულირებულია და შესაძლოა გამოყენებულ იქნეს დამოუკიდებლად; ეს საშუალებას გვაძლევს, შევქმნათ რთული ინტერფეისები - მარტივი კომპონენტებისგან.

### გავერკვეთ საწყის კოდში {#inspecting-the-starter-code}

თუ აპირებთ, რომ პრაქტიკული მუშაობა განაგრძოთ **თქვენს ბრაუზერში,** გახსენით **[საწყისი კოდი](https://codepen.io/gaearon/pen/oWWQNa?editors=0010)** ახალ ჩანართში. თუ გაგრძელებას **ლოკალურ გარემოში** აპირებთ, გახსენით `src/index.js` ფაილი, რომელიც თქვენი პროექტის საქაღალდეშია (ეს ფაილი [სამუშაო გარემოს მოწყობისას](#setup-option-2-local-development-environment) შექმენით).

ეს კოდი არის საწყისი მდგომარეობა იმისა, რის შექმნასაც ვაპირებთ. უკვე უზრუნველვყავით საჭირო CSS სტილები, ასე რომ, შეგიძლიათ ფოკუსირდეთ მხოლოდ React-ის შესწავლაზე და თამაში - ჯვრები და ნულების შექმნაზე.

თუ კოდს დააკვირდებით, შენიშნავთ, რომ მოცემული გვაქვს სამი React კომპონენტი:

* Square (უჯრედი)
* Board (დაფა)
* Game (თამაში)

ყოველი `Square` კომპონენტი ასახავს თითო `<button>`-ს, ხოლო `Board` კომპონენტი ასახავს - ცხრა `<Square />`-ს. `Game` კომპონენტი ასახავს `<Board />`-ს და რამოდნიმე ელემენტს, რომლებსაც მოგვიანებით გადავაკეთებთ. ჯერჯერობით არ გვაქვს არც ერთი ინტერაქტიული კომპონენტი.

### მონაცემთა მიწოდება Props-ის მეშვეობით {#passing-data-through-props}

მოდით, ვცადოთ რაიმე მონაცემის გადაწოდება `Board` კომპონენტიდან - `Square` კომპონენტში.

გირჩევთ, პრაქტიკული სამუშაოს განმავლობაში კოდი წეროთ თქვენი ხელით, არ გამოიყენოთ კოპირება-ჩასმის მიდგომა. ეს გაგიადვილებთ საკითხის გაგებას და გაგიუმჯობესებთ მეხსიერებას.

`Board` კომპონენტის `renderSquare` მეთოდში შევიტანოთ ცვლილება, `Square` კომპონენტს გადავაწოდოთ `value` თვისება:

```js{3}
class Board extends React.Component {
  renderSquare(i) {
    return <Square value={i} />;
  }
}
```

შევცვალოთ `Square` კომპონენტის `render` მეთოდი ისე, რომ მოვახდინოთ მიღებული მნიშვნელობის ჩვენება ეკრანზე. ამისათვის, `{/* TODO */}` ჩავანაცვლოთ `{this.props.value}`-ით:

```js{5}
class Square extends React.Component {
  render() {
    return (
      <button className="square">
        {this.props.value}
      </button>
    );
  }
}
```

ცვლილებამდე:

![React Devtools](../images/tutorial/tictac-empty.png)

ცვლილების შემდეგ: ყოველი უჯრედის შიგნით იხალავთ ციფრს.

![React Devtools](../images/tutorial/tictac-numbers.png)

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/aWWQOG?editors=0010)**

გილოცავთ! ახლახანს წარმატებით „გადააწოდეთ თვისება“ მშობელი - `Board` კომპონენტიდან, -- შვილობილ - `Square` კომპონენტს. თვისებების გადაწოდება React-ის აპლიკაციებში არის გზა ინფორმაციის დინებისა მშობელი კომპონენტებიდან - შვილობილ კომპონენტებში.

### გავხადოთ კომპონენტი ინტერაქტიული {#making-an-interactive-component}

მოდით, `Square` კომპონენტზე დაწკაპუნებისას, მასში ჩავწეროთ სიმბოლო - „X“.
პირველ რიგში, გადავაკეთოთ `Square` კომპონენტის `render()` ფუნქციის მიერ დაბრუნებული `button` ტეგი: 

```javascript{4}
class Square extends React.Component {
  render() {
    return (
      <button className="square" onClick={function() { console.log('დააწკაპუნეთ'); }}>
        {this.props.value}
      </button>
    );
  }
}
```

ამის შემდეგ, თუ თქვენ რომელიმე უჯრედზე დააწკაპუნებთ, თქვენი ბრაუზერის კონსოლში გამოჩნდება შეტყობინება - „დააწკაპუნეთ“.

>შენიშვნა
>
>იმისათვის, რომ ნაკლები ვწეროთ და თავი ავარიდოთ [`this`-ის დამაბნეველ ქცევას](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/), მოვლენების დამმუშავებლებისთვის (აქ და შემდგომში) გამოვიყენებთ [ისარ-ფუნქციების სინტაქსს](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions):
>
>```javascript{4}
>class Square extends React.Component {
>  render() {
>    return (
>      <button className="square" onClick={() => console.log('დააწკაპუნეთ')}>
>        {this.props.value}
>      </button>
>    );
>  }
>}
>```
>
>მიაქციეთ ყურედღება, როგორ გადავცემთ `onClick={() => console.log('click')}`-ით *ფუნქციას*, როგორც `onClick` თვისებას (prop). React ამ ფუნქციას გამოიძახებს მხოლოდ დაწკაპუნების შემდეგ. `() =>`-ის გამოტოვება, და `onClick={console.log('click')}`-ის დაწერა არის ხშირი შეცდომა. მსგავსი კოდი გაეშვება იმდენჯერ, რამდენჯერაც კომპონენტის ასახვა (render) მოხდება.

ჩვენი შემდეგი მიზანია `Square` კომპონენტმა „დაიმახსოვროს“, რომ მასზე მოხდა დაწკაპუნება და ჩავწეროთ მასში სიმბოლო - „X“. იმისათვის, რომ კომპონენტმა რაიმე „დაიმახსოვროს“, იყენებს **მდგომარეობას** (state).

React-ის კომპონენტებისათვის მდგომარეობის განსასაზღვრად, მათსავე კონსტრუქტორში `this.state` უნდა დავამატოთ. `this.state` უნდა განვიხილოთ, როგორც React-ის იმ კომპონენტის (კერძო) საკუთრება, რომელშიც განსაზღვრულია. მოდით, შევინახოთ `Square`-ის მიმდინარე მნიშვნელობა `this.state`-ში, და მოვახდინოთ მისი შეცვლა, როცა `Square`-ზე მოხდება დაწკაპუნება.

მდგომარეობისის (state) ინიციალიზებისათვის, პირველ რიგში, კლასს უნდა დავამატოთ კონსტრუქტორი:

```javascript{2-7}
class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      <button className="square" onClick={() => console.log('დააწკაპუნეთ')}>
        {this.props.value}
      </button>
    );
  }
}
```

>შენიშვნა
>
>როცა [JavaScript-ის კლასებში](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), შვილობილი კლასის კონსტრუქტორს განვსაზღვრავთ, ყოველთვის გვჭირდება `super`-ის გამოძახება. React-ის ყოველი კლასური კომპონენტი, რომელსაც `constructor` გააჩნია, უნდა იწყებოდეს `super(props)`-ის გამოძახებით.

ახლა მოდით, შევცვალოთ `Square` კომპონენტის `render` მეთოდი ისე, რომ აისახოს მიმდინარე მდგომარეობის (state) მნიშვნელობა დაწკაპუნებისას:

* `<button>` ტეგში, `this.props.value` შევცვალოთ `this.state.value`-ით.
* შევცვალოთ `onClick={...}` მოვლენის დამმუშავებელი `onClick={() => this.setState({value: 'X'})}`-ით.
* `className` და `onClick`  თვისებები მოვათავსოთ სხვადასხვა ხაზზე, რათა კოდი გავხადოთ უფრო მარტივად წაკითხვადი.

ამ ცვლილებების შემდეგ, `Square` კომპონენტის `render` მეთოდის მიერ დაბრუნებული `<button>` ტეგი ასე გამოიყურება:

```javascript{12-13,15}
class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      <button
        className="square"
        onClick={() => this.setState({value: 'X'})}
      >
        {this.state.value}
      </button>
    );
  }
}
```

`Square` კომპონენტის `render` მეთოდში `onClick` დამმუშავებლის მიერ `this.setState`-ის გამოძახებით React-ს ვეუბნებით, რომ `Square` კომპონენტი ასახოს ხელახლა, როცა მასში არსებულ `<button>`-ზე მოხდება დაწკაპუნება. განახლების შემდეგ, `Square` კომპონენტის `this.state.value`-ს მნიშვნელობა გახდება `'X'`, ამიტომ, თამაშის დაფაზე გამოჩნდება სიმბოლო -`X`.

როცა კომპონენტში ვიძახებთ `setState`-ს, React ანგარიშმიუცემლად ანახლებს ამ კომპონენტში მოთავსებულ, შვილობილ კომპონენტებსაც.

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/VbbVLg?editors=0010)**

### დეველოპერის ინსტრუმენტები {#developer-tools}

[Chrome](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en)-ისა და [Firefox](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)-ისათვის განკუთვნილი დამატება (extension) - React Devtools საშუალებას გაძლევთ, თქვენი ბრაუზერის დეველოპერის ხელსაწყოთა ჩანართიდან დააკვირდეთ React კომპონენტების იერარქიას.

<img src="../images/tutorial/devtools.png" alt="React Devtools" style="max-width: 100%">

React Devtools დამატება საშუალებას მოგცემთ, შეამოწმოთ თქვენი React კომპონენტების თვისებები (props) და მდგომარეობა (state).

React Devtools დამატების ინსტალაციის შემდეგ, შეგიძლიათ, მაუსის მარჯვენა ღილაკით დააწკაპუნოთ გვერდზე არსებულ ნებისმიერ ელემენტზე, შემდეგ დააწკაპუნოთ `გვერდის გამოკვლევაზე` (Inspect), რათა გახსნათ დეველოპერის ხელსაწყოთა ჩანართი, რომელშიც მარჯვნივ გამოჩნდება React-ის განყოფილებები ("⚛️ Components" და "⚛️ Profiler"). კომპონენტების იერარქიის სანახავად გამოიყენება "⚛️ Components" განყოფილება.

**მაგრამ იმისათვის, რომ ეს CodePen-ზე ავამუშავოთ, რამდენიმე დამატებითი ეტაპის გავლაა საჭირო:**

1. გაიარეთ ავტორიზაცია ან დარეგისტრირდით, და დაადასტურეთ თქვენი ელ. ფოსტის მისამართის ავთენტურობა (აუცილებელია სპამის თავიდან ასაცილებლად).
2. დააწკაპუნეთ "Fork" ღილაკზე.
3. დააწკაპუნეთ "Change View"-ზე და შემდეგ აირჩიეთ "Debug mode". 
4. ახალ ჩანართში, რომელიც გაიხსნება, დეველოპერის ხელსაწყოთა შორის უნდა იყოს React-ის განყოფილება.

## დავასრულოთ თამაშზე მუშაობა {#completing-the-game}

ჩვენ უკვე მზად გვაქვს ძირითადი ელემენტები ჩვენი თამაშისთვის - ჯვრები და ნულები. თამაშის სრულყოფისათვის, გვჭირდება „X“ და „O“ სიმბოლოების მონაცვლეობითი ასახვა დაფაზე, და გზა - გამარჯვებულის გამოსავლენად.

### მდგომარეობის გადატანა ზემოთ {#lifting-state-up}

ამჟამად, ყოველი `Square` კომპონენტი, ინდივიდუალურად ინახავს თამაშის მდგომარეობას. იმისათვის, რომ გამარჯვებულის განსაზღვრა შევძლოთ, ცხრავე უჯრედის მნიშვნელობა ერთ ადგინზე უნდა შევინახოთ.

შესაძლოა ვიფიქროთ, რომ საჭიროა, უბრალოდ `Board` კომპონენტმა მოახდინოს ყოველი `Square` კომპონენტის მდგომარეობის შემოწმება. მიუხედავად იმისა, რომ ასეთი რამ React-ში შესაძლებელია, ჩვენ უარვყოფთ ამ მიდგომას, რადგან კოდი ხდება რთულად გასაგები, რთულია მისი [რესტრუქტურიზაცია](https://en.wikipedia.org/wiki/Code_refactoring) და იზრდება შეცდომების დაშვების ალბათობა. ყოველ `Square` კომპონენტში ცალ-ცალკე შენახვის ნაცვლად, თამაშის მდგომარეობის შენახვისათვის საუკეთესო ადგილია მშობელი, - `Board` კომპონენტი. `Board` კომპონენტს შეუძლია თვისების (props) გადაწოდების გზით უთხრას თითოეულ `Square`-ს, თუ რა უნდა ასახოს ეკრანზე, [ისევე, როგორც ეს გავაკეთეთ, როცა თითოეულ `Square`-ს გადავაწოდეთ ციფრი](#passing-data-through-props).

**იმისათვის, რომ შევაგროვოთ მრავალი შვილობილი კომპონენტების მონაცემები, ან გვქონდეს ორ კომპონენტს შორის კავშირი, საჭიროა, შევქმნათ საზიარო მდგომარეობა (state) მათ მშობელ კომპონენტში. მშობელი კომპონენტიდან შეგვიძლია მდგომარეობა გადავაწოდოთ შვილობილ კომპონენტებს თვისებების (props) სახით; ამ გზით, შვილობილი კომპონენტები ერწყმიან ერთმანეთს და - მშობელ კომპონენტს.**

მდგომარეობის (state) გადატანა მშობელ კომპონენტში ხშიარია, -- როცა ხდება React-ის კომპონენტების რესტრუქტურიზაცია. მოდით, გამოვიყენოთ ხელსაყრელი შესაძლებლობა და ვცადოთ ამის გაკეთება.

`Board` კომპონენში დავამატოთ კონსტრუქტორი და საწყის მდგომარეობად განვსაზღვროთ ცხრა ელემენტისაგან (რომელთა მნიშვნელობაა - `null`) შემდგარი მასივი. ეს ელემენტები შეესაბამება ცხრა უჯრედს:

```javascript{2-7}
class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
    };
  }

  renderSquare(i) {
    return <Square value={i} />;
  }
```

შემდგომში, როცა დაფას შევავსებთ, `this.state.squares` მასივი დაემსგავსება რაღაც ასეთს:

```javascript
[
  'O', null, 'X',
  'X', 'X', 'O',
  'O', null, null,
]
```

`Board` კომპონენტის `renderSquare` მეთოდი ამჟამად ასე გამოიყურება:

```javascript
  renderSquare(i) {
    return <Square value={i} />;
  }
```

დასაწყისში, ჩვენ [გადავაწოდეთ `value` თვისება შვილობილ კომპონენტს](#passing-data-through-props) `Board` კომპონენტიდან, რათა ყოველ უჯრედში გვეჩვენებინა ციფრები 0-დან 8-ის ჩათვლით. შემდეგ, ჩვენ ჩავანაცვლეთ ციფრები სიმბოლო „X“-ით, რომელიც განვსაზღვრეთ [უშუალოდ `Square` კომპონენტის მდგომარეობად](#making-an-interactive-component). ამიტომაც აღარ აქცევს ყურადღებას `Square` კომპონენტი `Board` კომპონენტისაგან გადმოწოდებულ `value` თვისებას.

ახლა, ისევ თვისების გადაწოდების ხერხს გამოვიყენებთ. ჩვენ გადავეკეთებთ `Board` კომპონენტს ისე, რომ ყოველ ცალკეულ უჯრედს უთხრას, თუ რა არის მისი მიმდინარე მნიშვნელობა (`'X'`, `'O'`, თუ `null`). `Board` კომპონენტის კონსტრუქტორში უკვე განვსაზღვრეთ `squares` მასივი, ახლა საჭიროა `Board` კომპონენტის `renderSquare` მეთოდის გადაკეთება ისე, რომ მნიშვნელობები ამ მასივიდან წაიკითხოს:

```javascript{2}
  renderSquare(i) {
    return <Square value={this.state.squares[i]} />;
  }
```

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/gWWQPY?editors=0010)**

ახლა ყოველი `Square` კომპონენტი მიიღებს `value` თვისებას, რომლის მნიშვნელობაც იქნება `'X'`, `'O'`, ან `null` (ეს უკანასკნელი ცარიელი უჯრედებისათვის).

ახლა საჭიროა შევცვალოთ უჯრედზე დაწკაპუნების შედეგი. ამჟამად `Board` კომპონენტი ადგენს, თუ რომელი უჯრედებია შევსებული. უნდა ვიპოვოთ გზა, რომლითაც `Square` კომპონენტიდან მოვახერხებთ `Board` კომპონენტის მდგომარეობის (state) განახლებას. რადგან მდგომარეობა მიჩნეულია იმ კომპონენტის კერძო მახასიათებლად, რომელშიც არის განსაზღვრული, ჩვენ არ შეგვიძლია `Board` კომპონენტის მდგომარეობის განახლება უშუალოდ `Square` კომპონენტიდან.

ნაცვლად ამისა, ჩვენ `Board` კომპონენტიდან `Square` კომპონენტს გადავაწვდით ფუნქციას, და უჯრედზე დაწკაპუნებისას, `Square` კომპონენში მოხდება ამ ფუნქციის გამოძახება. მოდით, შევცვალოთ `Board` კომპონენტის `renderSquare` მეთოდი:

```javascript{5}
  renderSquare(i) {
    return (
      <Square
        value={this.state.squares[i]}
        onClick={() => this.handleClick(i)}
      />
    );
  }
```

>შენიშვნა
>
>უკეთესი წაკითხვადობისათვის, დაბრუნებული ელემენტი წარმოვადგინეთ მრავალ ხაზზე, და მოვაქციეთ ფრჩხილებს შორის, რადგან, ზოგადად, JavaScript-ში `return`-ის შემდეგ არ იწერება წერტილ-მძიმე: ეს იწვევს კოდის მუშაობის შეწყვეტას.

ამჟამად, `Board` კომპონენტიდან `Square` კომპონენტს ვაწვდით ორ თვისებას: `value` და `onClick`. `onClick` თვისება არის ფუნქცია, რომელიც `Square` კომპონენტმა უნდა გამოიძახოს მასზე (უჯრედზე) დაწკაპუნებისას. ახლა საჭიროა, `Square` კომპონენტში შევიტანოთ შემდეგი ცვლილებები:

* `Square` კომპონენტის `render` მეთოდში `this.state.value` ჩავანაცვლოთ `this.props.value`-ით.
* `Square` კომპონენტის `render` მეთოდში `this.setState()` ჩავანაცვლოთ `this.props.onClick()`-ით.
* `Square` კომპონენტიდან ამოვშალოთ `constructor`, რადგან `Square` კომპონენტი აღარ არის თამაშის მდგომარეობის (state) შენახვაზე პასუხისმგებელი.

ამ ცვლილებების შემდეგ `Square` კომპონენტი ასე გამოიყურება:

```javascript{1,2,6,8}
class Square extends React.Component {
  render() {
    return (
      <button
        className="square"
        onClick={() => this.props.onClick()}
      >
        {this.props.value}
      </button>
    );
  }
}
```

როცა უჯრედზე დავაწკაპუნებთ, მოხდება `Board` კომპონენტის მიერ უზრუნველყოფილი (გადაწოდებული) `onClick` ფუნქციის გამოძახება. განვიხილოთ, როგორ მიიღწევა ეს:

1. DOM-ის ჩაშენებული `<button>` კომპონენტის `onClick` თვისება ეუბნება React-ს, შექმნას მოვლენის (დაწკაპუნების) დამმუშავებელი.
2. როცა ღილაკზე დაწკაპუნება მოხდება, React გამოიძახებს `Square` კომპონენტის `render()` მეთოდში განსაზღვრულ - `onClick` - მოვლენის დამმუშავებელს.
3. ეს მოვლენის დამმუშავებელი იძახებს `this.props.onClick()`-ს. `Square` კომპონენტის `onClick` თვისება (prop) გადმოწოდებულია `Board` კომპონენტიდან.
4. რადგან `Board` კომპონენტიდან `Square` კომპონენტში გადმოწოდებულია - `onClick={() => this.handleClick(i)}`, დაწკაპუნებისას, `Square` კომპონენტი იძახებს `this.handleClick(i)`-ს.
5. ჯერჯერობით არ განგვისაზღვრავს `handleClick()` მეთოდი, ამიტომ, ჩვენი კოდი არ იმუშავებს. თუ თქვენ ახლა უჯრედზე დააწკაპუნებთ, დაინახავთ წითელ ეკრანს (შეცდომის) მსგავსი შეტყობინებით:  „this.handleClick is not a function“.

>შენიშვნა
>
>DOM-ის `<button>` ელემენტის `onClick` ატრიბუტს React-ისათვის განსაკუთრებული მნიშვნელობა აქვს, რადგან, ეს არის ჩაშენებული კომპონენტი. `Square`-ის მსგავსი, ინდივიდუალური კომპონენტებისათვის სახელების შერჩევა თქვენს განკარგულებაშია. ჩვენ შეგვიძლია, `Square`-ის `onClick` თვისებას, ან `Board`-ის `handleClick` მეთოდს დავარქვათ ნებისმიერი სახელი, და კოდი ისევ იგივენაირად იმუშავებს. React-ში, ზოგადად, მიღებულია, რომ მახასიათებლებს (props), რომლებიც მოვლენებს (events) წარმოადგენენ,  ვუწოდოთ - `on[Event]`, ხოლო მოვლენების დამმუშავებელ მეთოდებს - `handle[Event]`.

როდესაც უჯრედზე დავაწკაპუნებთ, მივიღებთ შეცდომას, რადგან `handleClick` მეთოდი ჯერ არ განგვისაზღვრავს. მოდით, `Board` კლასში დავამატოთ `handleClick` მეთოდი:

```javascript{9-13}
class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
    };
  }

  handleClick(i) {
    const squares = this.state.squares.slice();
    squares[i] = 'X';
    this.setState({squares: squares});
  }

  renderSquare(i) {
    return (
      <Square
        value={this.state.squares[i]}
        onClick={() => this.handleClick(i)}
      />
    );
  }

  render() {
    const status = 'Next player: X';

    return (
      <div>
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
```

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/ybbQJX?editors=0010)**

ამ ცვლილებების შემდეგ, ჩვენ შევძლებთ უჯრედების შევსებას მათსე დაწკაპუნებით ისევე, როგორც ადრე. თუმცა, ახლა ყოველი ცალკეული `Square` კომპონენტის ნაცვლად, მდგომარეობა (state) ინახება - `Board` კომპონენტში. როცა `Board` კომპონენტის მდგომარეობა იცვლება, ანგარიშმიუცემლად ხდება ყოველი `Square` კომპონენტის ხელახლა ასახვა (render). ყოველი უჯრედის მდგომარეობის შენახვა `Board` კომპონენტში, მომავალში, საშუალებას მოგვცემს: გამოვავლინოთ გამარჯვებული.

მას შემდეგ, რაც `Square` კომპონენტი აღარ ინახავს მდგომარეობას, უჯრედები მნიშვნელობებს იღებენ `Board` კომპონენტისაგან, და ატყობინებენ `Board` კომპონენტს, როცა მათზე ხდება დაწკაპუნება. React-ის ენით რომ ვთქვათ, `Square` კომპონენტი ახლა არის - **კონტროლირებადი კომპონენტი**. მას სრულად აკონტროლებს `Board` კომპონენტი.

გასათვალისწინებელია, `handleClick` მეთოდში როგორ ვქმნით გარდაქმნისათვის `squares` მასივის ასლს `.slice()`-ის გამოძახებით იმის ნაცვლად, რომ გარდავქმნათ უკვე არსებული მასივი. სახელმძღვანელოს შემდეგ განყოფილებაში განვმარტავთ, თუ რატომ შევქმენით `squares` მასივის ასლი.

### რატომ არის უცვლადობა მნიშვნელოვანი? {#why-immutability-is-important}

კოდის წინა მაგალითში, `.slice()` მეთოდის გამოყენებით შევქმენით `squares` მასივის ასლი, ნაცვლად იმისა, რომ ცვლილება მოგვეხდინა უშუალოდ (არსებულ) მასივზე. ახლა განვიხილავთ უცვლადობას და გავარკვევთ, თუ რატომ არის მისი შესწავლა ასე მნიშვნელოვანი.

მონაცემში ცვლილების შეტანის ორი საშუალება არსებობს. პირველი საშუალება არის უშუალოდ მონაცემის მნიშვნელობის *მუტაცია* (შეცვლა). მეორე საშუალებაა - ამ მონაცემის ჩანაცვლება მისი ასლით, რომელიც შეიცავს სასურველ ცვლილებს.

#### მონაცემთა უშუალო ცვლილება {#data-change-with-mutation}
```javascript
var player = {score: 1, name: 'გიორგი'};
player.score = 2;
// ახლა player-ის მნიშვნელობა არის {score: 2, name: 'გიორგი'}
```

#### მონაცემთა ირიბი ცვლილება {#data-change-without-mutation}
```javascript
var player = {score: 1, name: 'გიორგი'};

var newPlayer = Object.assign({}, player, {score: 2});
// player-ის მნიშვნელობა არ შეცვლილა, მაგრამ newPlayer-ის მნიშვნელობა არის {score: 2, name: 'გიორგი'}

// ან, თუ თქვენ იყენებთ ობიექტის განვრცობის (spread) სინტაქსს, შეგიძლიათ დაწეროთ:
// var newPlayer = {...player, score: 2};
```

საბოლოო შედეგი იგივე იქნება, ოღონდ (საწყისი მონაცემის) უშუალო ცვლილების გარეშე. ამ მიდგომის რამდენიმე უპირატესობა განხილულია ქვემოთ.

#### მარტივდება რთული ფუნქციონალი {#complex-features-become-simple}

უცვლადობა გაცილებით ამარტივებს რთული ფუნქციონალის გამართვას. ამ სახელმძღვანელოში, მოგვიანებით, შევიმუშავებთ „დროში მოგზაურობის“ ფუნქციონალს, რომელიც საშუალებას მოგვცემს, გადავხედოთ თამაშის ისტორიას და წინა სვლებზე „გადავხტეთ“. ეს არ არის მხოლოდ თამაშებისათვის განკუთვნილი ფუნქციონალი, წინ და უკან „ხტომის“ შესაძლებლობა ხშირად გვხვდება სხვადასხვა სახის აპლიკაციებში. მონაცემთა უშუალო ცვლილების თავიდან აცილებით საშუალება გვეძლევა, ხელუხლებლად შევინარჩუნოთ თამაშის ისტორიის უწინდელი მდგომარეობა, და მოგვიანებით ხელახლა გამოვიყენოთ.

#### ცვლილებების გამოვლენა {#detecting-changes}

ცვალებად ობიექტებში ცვლილებების გამოვლენა რთულია, რადგან ისინი უშუალოდ იცვლებიან. ასეთ შემთხვევაში ცვლილებების გამოსავლენად ცვალებადი ობიექტის შედარება უნდა მოხდეს მისი წინა ვერსიების ასლი ობიექტების მთელ ხესთან.

უცვლად ობიექტებში ცვლილებების გამოვლენა ბევრად მარტივია. თუ წარმოდგენილი უცვლადი ობიექტი წინასგან განსხვავებულია, გამოდის, რომ ამ ობიექტში მოხდა ცვლილება.

#### დადგენა იმისა, თუ როდის უნდა მოხდეს React-ში ხელახალი ასახვა {#determining-when-to-re-render-in-react}

უცვლადობის მთავარი ხეირი ის არის, რომ ის React-ში _სუფთა (pure) კომპონენტების_ შექმნაში გვეხმარება. უცვლად მონაცემებში ადვილი გამოსავლენია ცვლილება, რაც გვეხმარება იმის დადგენაში, თუ როდის საჭიროებს კომპონენტი ხელახლა ასახვას (render).

[წარმადობის გაუმჯობესების](/docs/optimizing-performance.html#examples) შესახებ წაკითხვით შეიტყობთ მეტს `shouldComponentUpdate()`-ისა და იმის შესახებ, თუ როგორ იქმნება _სუფთა (pure) კომპონენტები_.

### ფუნქციური კომპონენტები {#function-components}

მოდით, `Square` კომპონენტი გადავაკეთოთ - **ფუნქციურ კომპონენტად**.

React-ში **ფუნქციური კომპონენტი** არის კომპონენტის ჩაწერის უფრო მოკრძალებული ხერხი. ასეთი კომპონენტები შეიცავენ მხოლოდ `render` მეთოდს, და არ გააჩნიათ საკუთარი მდგომარეობა (state). `React.Component`-ის შვილობილი კლასის განსაზღვრის ნაცვლად, შეგვიძლია, შევქმნათ მარტივი ფუნქცია, რომელსაც (არგუმენტის სახით) გადაეცემა `props`, და აბრუნებს ვიზუალურ იერარქიას. ფუნქციური კომპონენტის ჩაწერა, კლასურთან შედარებით, ნაკლებად შრომატევადია და მრავალი კომპონენტი შეიძლება გამოისახოს ამ ხერხით.

ჩავანაცვლოთ `Square` კლასი ამ ფუნქციით:

```javascript
function Square(props) {
  return (
    <button className="square" onClick={props.onClick}>
      {props.value}
    </button>
  );
}
```

`this.props` ორივეგან, სადაც ფიგურირებს, ჩავანაცვლეთ `props`-ით.

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/QvvJOv?editors=0010)**

>შენიშვნა
>
>როცა `Square` კომპონენტი გადავაკეთეთ ფუნქციურ კომპონენტად, ასევე შევცვალეთ ჩანაწერი `onClick={() => this.props.onClick()}`, უფრო მოკლე ჩანაწერით - `onClick={props.onClick}` (გაითვალისწინეთ, *ორივე* მხარეს მოშორდა ფრჩხილები).

### სვლების მონაცვლეობა {#taking-turns}

ახლა, საჭიროა, გამოვასწოროთ ჩვენი თამაშის აშკარა ნაკლი: შეუძლებელია, დაფაზე გამოისახოს სიმბოლო - „O“.

ნაგულისხმევად, პირველი სვლას განახორციელებს - „X“. ნაგულისხმევი მნიშვნელობის განსაზღვრა შეგვიძლია `Board` კომპონენტის კონსტრუქტორში საწყისი მდგომარეობის გარდაქმნით:

```javascript{6}
class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
      xIsNext: true,
    };
  }
```

მოთამაშის ყოველი სვლის შემდეგ, `xIsNext` (ლოგიკური გამოსახულება)-ის მნიშვნელობა შეიცვლება საპირისპიროთი, - რათა დადგინდეს შემდეგი სვლის მფლობელის ვინაობა, - და მოხდება თამაშის მდგომარეობის შენახვა. მოდით, განვაახლოთ `Board` კომპონენტის `handleClick` ფუნქცია, რათა მოვახდინოთ `xIsNext`-ის მნიშვნელობის შეცვლა - საპირისპიროთი:

```javascript{3,6}
  handleClick(i) {
    const squares = this.state.squares.slice();
    squares[i] = this.state.xIsNext ? 'X' : 'O';
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }
```

ამ ცვლილებით, „X“-სა და „O“-ს შორის მოხდება სვლების მონაცვლეობა. სცადეთ!

მოდით, `Board` კომპონენტის `render`-ში „სტატუსის“ ტექსტიც შევცვალოთ ისე, რომ გვაჩვენოს მოთამაშე, რომელმაც უნდა გააკეთოს შემდეგი სვლა:

```javascript{2}
  render() {
    const status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');

    return (
      // დანარჩენი არ შეცვლილა
```

ამ ცვლილებების შემდეგ, თქვენი `Board` კომპონენტი ასე უნდა გამოიყურებოდეს:

```javascript{6,11-16,29}
class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
      xIsNext: true,
    };
  }

  handleClick(i) {
    const squares = this.state.squares.slice();
    squares[i] = this.state.xIsNext ? 'X' : 'O';
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }

  renderSquare(i) {
    return (
      <Square
        value={this.state.squares[i]}
        onClick={() => this.handleClick(i)}
      />
    );
  }

  render() {
    const status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');

    return (
      <div>
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
```

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/KmmrBy?editors=0010)**

### გამარჯვებულის გამოვლენა {#declaring-a-winner}

ახლა, როცა ვაჩვენებთ მოთამაშეს, რომელმაც შემდეგი სვლა უნდა გააკეთოს, ასევე უნდა ვაჩვენოთ თამაშის დასრულებისას, რომ სვლები აღარ არის. განათავსეთ ამ დამხმარე ფუნქციის ასლი თქვენი ფაილის ბოლოში:

```javascript
function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

გადაცემული 9 უჯრედის მასივით, ეს ფუნქცია გამოავლენს გამარჯვებულს, და შესაბამისად დააბრუნებს `'X'`-ს, `'O'`-ს, ან - `null`-ს.

`Board` კომპონენტის `render` ფუნქციაში გამოვიძახებთ `calculateWinner(squares)`-ს იმის შესამოწმებლად, გაიმარჯვა თუ არა (რომელიმე) მოთამაშემ. თუ მოთამაშე გაიმარჯვებს, შეგვიძლია გამოვაჩინოთ შეტყობინება "გამარჯვებული: X", ან - "გამარჯვებული: O". `Board` კომპონენტის `render` ფუნქციაში, `status`-ის გამოცხადების მიდგომა ასე უნდა გადავაკეთოთ:

```javascript{2-8}
  render() {
    const winner = calculateWinner(this.state.squares);
    let status;
    if (winner) {
      status = 'Winner: ' + winner;
    } else {
      status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
    }

    return (
      // დანარჩენი არ შეცვლილა
```

ახლა ჩვენ შეგვიძლია `Board` კომპონენტის `handleClick` ფუნქცია გადავაკეთოთ ისე, რომ თუ ვიღაცამ გაიმარჯვა, ან თუ უჯრედი უკვე შევსებულია, მოხდეს ფუნქციიდან ნაადრევი გამოსვლა:

```javascript{3-5}
  handleClick(i) {
    const squares = this.state.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? 'X' : 'O';
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }
```

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/LyyXgK?editors=0010)**

გილოცავთ! ახლა თქვენ გაქვთ მუშა თამაში - ჯვრები და ნულები. ამასთანავე, ახლახანს შეისწავლეთ React-ის საფუძვლები. როგორც ჩანს, აქ საბოლოო გამარჯვებული *თქვენ ხართ*.

## დავამატოთ დროში მოგზაურობა {#adding-time-travel}

როგორც დასკვნითი სავარჯიშო, მოდით, ჩვენს თამაშს დავამატოთ „დროის უკან დაბრუნების“, ანუ წინა სვლებზე დაბრუნების შესაძლებლობა.

### სვლების ისტორიის შენახვა {#storing-a-history-of-moves}

თუ მოვახდენდით `squares` მასივის უშუალო გარდაქმნას, „დროში მოგზაურობის“ ფუნქციონალის განხორციელება ძალიან რთული იქნებოდა.

თუმცა, ჩვენ გამოვიყენეთ `slice()` მეთოდი, რათა ყოველი სვლის განხორციელებისას შექმნილიყო `squares` მასივის ახალი ასლი, [თავდაპირველი მნიშვნელობის უშუალო ცვლილების (მუტაციის) გარეშე](#why-immutability-is-important). ეს `squares` მასივის ყოველი წარსული მდგომარეობის შენახვისა, და უკვე შესრულებულ სვლებს შორის გადაადგილების საშუალებას მოგვცემს.

`squares` მასივის უწინდელ ვერსიებს შევინახავთ სხვა მასივში, რომელსაც `history`-ს დავარქმევთ. `history` მასივი შეინახავს დაფის ყოველ მდგომარეობას - პირველიდან ბოლო სვლამდე. მისი აგებულება ასეთი იქნება:

```javascript
history = [
  // პირველ სვლამდე
  {
    squares: [
      null, null, null,
      null, null, null,
      null, null, null,
    ]
  },
  // პირველი სვლის შემდეგ
  {
    squares: [
      null, null, null,
      null, 'X', null,
      null, null, null,
    ]
  },
  // მეორე სვლის შემდეგ
  {
    squares: [
      null, null, null,
      null, 'X', null,
      null, null, 'O',
    ]
  },
  // ...
]
```

ახლა საჭიროა გადავწყვიტოთ, თუ რომელი კომპონენტის მდგომარეობას (state) მივაკუთნებთ `history`-ს.

### მდგომარეობის გადატანა ზემოთ. ისევ {#lifting-state-up-again}

საჭიროა, `Game` კომპონენტში წარმოვადგინოთ უწინდელი სვლების სია. ამისათვის, მას სჭირდება წვდომა `history`-ზე, ასე რომ, `history` უნდა მივაკუთვნოთ `Game` კომპონენტის მდგომარეობას.

`history`-ის `Game` კომპონენტის მდგომარეობაში განთავსების შემდეგ, შეგვიძლია, შვილობილი - `Board` - კომპონენტიდან `squares` მდგომარეობა (state) წავშალოთ. როგორც `Square` კომპონენტიდან [„გადავიტანეთ მდგომარეობა ზემოთ“](#lifting-state-up), - `Board` კომპონენტში, ასევე გადაგვაქვს `Board` კომპონენტიდან მშობელ, - `Game` კომპონენტში. ამით `Game` კომპონენტს ეძლევა სრული კონტროლი `Board` კომპონენტის მონაცემებზე, და საშუალება აქვს, `Board` კომპონენტს გამოასახვინოს უწინდელი სვლები `history`-დან:

პირველ რიგში, უნდა განვსაზღვროთ `Game` კომპონენტის საწყისი მდგომარეობა მის კონსტრუქტორში:

```javascript{2-10}
class Game extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      history: [{
        squares: Array(9).fill(null),
      }],
      xIsNext: true,
    };
  }

  render() {
    return (
      <div className="game">
        <div className="game-board">
          <Board />
        </div>
        <div className="game-info">
          <div>{/* status */}</div>
          <ol>{/* TODO */}</ol>
        </div>
      </div>
    );
  }
}
```

ამის შემდეგ გვჭირდება, რომ `Board` კომპონენტმა, `Game` კომპონენტისაგან მიიღოს `squares` და `onClick` თვისებები. მას შემდეგ, რაც `Board` კომპონენტში არსებული, ერთადერთი დაწკაპუნების დამმუშავებელი გვაქვს მრავალი `Square`-სათვის, იმის გასაგებად, თუ რომელ უჯრედზე მოხდა დაწკაპუნება, საჭიროა, ყოველი `Square`-ის მდებარეობა გადავცეთ `onClick` დამმუშავებელს. `Board` კომპონენტის გადასაკეთებლად უნდა გავიაროთ შემდეგი ეტაპები:

* `Board`-იდან ამოვშალოთ `constructor`.
* `Board`-ის `renderSquare` მეთოდში, `this.state.squares[i]` ჩავანაცვლოთ `this.props.squares[i]`-ით.
* `Board`-ის `renderSquare` მეთოდში, `this.handleClick(i)` ჩავანაცვლოთ `this.props.onClick(i)`-ით.

ახლა `Board` კომპონენტი ასე გამოიყურება:

```javascript{17,18}
class Board extends React.Component {
  handleClick(i) {
    const squares = this.state.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? 'X' : 'O';
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }

  renderSquare(i) {
    return (
      <Square
        value={this.props.squares[i]}
        onClick={() => this.props.onClick(i)}
      />
    );
  }

  render() {
    const winner = calculateWinner(this.state.squares);
    let status;
    if (winner) {
      status = 'Winner: ' + winner;
    } else {
      status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
    }

    return (
      <div>
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
```

მოდით, განვაახლოთ `Game` კომპონენტის `render` ფუნქცია ისე, რომ თამაშის სტატუსის საჩვენებლად გამოყენებულ იქნეს ისტორიის უახლესი ჩანაწერი:

```javascript{2-11,16-19,22}
  render() {
    const history = this.state.history;
    const current = history[history.length - 1];
    const winner = calculateWinner(current.squares);

    let status;
    if (winner) {
      status = 'Winner: ' + winner;
    } else {
      status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
    }

    return (
      <div className="game">
        <div className="game-board">
          <Board
            squares={current.squares}
            onClick={(i) => this.handleClick(i)}
          />
        </div>
        <div className="game-info">
          <div>{status}</div>
          <ol>{/* TODO */}</ol>
        </div>
      </div>
    );
  }
```

რადგან `Game` კომპონენტი უკვე ასახავს თამაშის სტატუსს, შეგვიძლია იგივე საქმეზე პასუხისმგებელი კოდი ამოვიღოთ `Board` კომპონენტის `render` მეთოდიდან. ცვლილებების შემდეგ, `Board` კომპონენტის `render` მეთოდი ასე გამოიყურება:

```js{1-4}
  render() {
    return (
      <div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
```

დაბოლოს, გვჭირდება `handleClick` მეთოდის `Board` კომპონენტიდან - `Game` კომპონენტში გადატანა. ასევე, დაგვჭირდება `handleClick` მეთოდში ცვლილებების შეტანა, რადგან `Game` კომპონენტის მდგომარეობის (state) სტრუქტურა განსხვავებულია. `history`-ში ახალი ჩანაწერების შეტანა (კონკატენაცია) მოხდება `Game` კომპონენტის `handleClick` მეთოდიდან:

```javascript{2-4,10-12}
  handleClick(i) {
    const history = this.state.history;
    const current = history[history.length - 1];
    const squares = current.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? 'X' : 'O';
    this.setState({
      history: history.concat([{
        squares: squares,
      }]),
      xIsNext: !this.state.xIsNext,
    });
  }
```

>შენიშვნა
>
>ნაცვლად (მასივის) `push()` მეთოდისა, რომელიც, ალბათ უფრო ნაცნობია თქვენთვის, გირჩევთ `concat()` მეთოდის გამოყენებას, რომელიც არ ახდენს თავდაპირველი მასივის უშუალო ცვლილებას.

ამ ეტაპზე, `Board` კომპონენტს მხოლოდ `renderSquare` და `render` მეთოდები სჭირდება. თამაშის მდგომარეობა (state) და `handleClick` მეთოდი უნდა იყოს - `Game` კომპონენტში.

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/EmmOqJ?editors=0010)**

### უწინდელი სვლების ჩვენება {#showing-the-past-moves}

რამდენადაც ჩვენ ვიწერთ თამაშის ისტორიას, შეგვიძლია, მოთამაშეს ვუჩვენოთ წინა სვლების სია.

როგორც ადრე განვიხილეთ, React-ის ელემენტები ჩვეულებრივი JavaScript-ის ობიექტებია, რომლებიც შეგვიძლია გავავრცელოთ აპლიკაციის ფარგლებში. React-ში მრავალი ობიექტის ასახვისათვის, შეგვიძლია, React-ის ელემენტთა მასივი გამოვიყენოთ.

JavaScript-ში მასივებს გააჩნიათ [`map()` მეთოდი](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), რომელიც, ჩვეულებრივ, მონაცემთა გარდაქმნისათვის გამოიყენება. მაგალითად:

```js
const numbers = [1, 2, 3];
const doubled = numbers.map(x => x * 2); // [2, 4, 6]
```

`map` მეთოდის გამოყენებით, შეგვიძლია სვლების ისტორია React-ის ელემენტებით გამოვსახოთ: წარმოვადგინოთ ღილაკების სია, რომლებიც წინა სვლებზე „გადავხტომაში“ დაგვეხმარება.

მოდით, `Game` კომპონენტის `render` მეთოდში `history`-ის წარმოსადგენად გამოვიყენოთ `map` მეთოდი:

```javascript{6-15,34}
  render() {
    const history = this.state.history;
    const current = history[history.length - 1];
    const winner = calculateWinner(current.squares);

    const moves = history.map((step, move) => {
      const desc = move ?
        'Go to move #' + move :
        'Go to game start';
      return (
        <li>
          <button onClick={() => this.jumpTo(move)}>{desc}</button>
        </li>
      );
    });

    let status;
    if (winner) {
      status = 'Winner: ' + winner;
    } else {
      status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
    }

    return (
      <div className="game">
        <div className="game-board">
          <Board
            squares={current.squares}
            onClick={(i) => this.handleClick(i)}
          />
        </div>
        <div className="game-info">
          <div>{status}</div>
          <ol>{moves}</ol>
        </div>
      </div>
    );
  }
```

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/EmmGEa?editors=0010)**

თამაშის ისტორიის ყოველი სვლის ასახვისთვის, ჩვენ ვქმნით სიის ელემენტს - `<li>`, რომელიც შეიცავს ღილაკს - `<button>`. ღილაკს აქვს `onClick` დამმუშავებელი, რომელიც `this.jumpTo()` მეთოდს იძახებს. ჩვენ ჯერ არ შეგვიქმნია `jumpTo()` მეთოდი. ამჟამად, ჩვენ უნდა დავინახოთ ყოველი (განხორციელებული) სვლების სია და გაფრთხილება დეველოპერის ხელსაწყოთა ჩანართში (კონსოლში), რომელიც გვეუბნება:

>  Warning:
>  Each child in an array or iterator should have a unique "key" prop. Check the render method of "Game".

რაც ითარგმნება, როგორც:

>  გაფრთხილება:
>  მასივის ყოველ ელემენტს ან იტერატორს (გამმეორებელს) უნდა გააჩნდეს უნიკალური „key“ (გასაღები) თვისება. შეამოწმეთ `Game`-ის `render` მეთოდი.

მოდით, განვიხილოთ ამ გაფრთხილების მნიშვნელობა.

### გასაღების შერჩევა {#picking-a-key}

სიის გამოსახვისას, ყოველი გამოსახული სიის ელემენტის შესახებ React ინახავს რაღაც ინფორმაციას. სიის განახლებისას, React-ს სჭირდება, დაადგინოს, თუ რა შეიცვალა. ჩვენ შესაძლოა: დავამატეთ, ამოვშალეთ, ხელახლა განვათავსეთ, ან - განვაახლეთ სიის ელემენტები.

წარმოიდგინეთ, ამის გარდაქმნა

```html
<li>დემნა: 7 დარჩენილი სამუშაო</li>
<li>ზურა: 5 დარჩენილი სამუშაო</li>
```

ამაში

```html
<li>ზურა: 9 დარჩენილი სამუშაო</li>
<li>ბარბარე: 8 დარჩენილი სამუშაო</li>
<li>დემნა: 5 დარჩენილი სამუშაო</li>
```

გარდა შეცვლილი ციფრებისა, ადამიანი, რომელიც ამას წაიკითხავს ალბათ იტყვის, რომ დემნასა და ზურას ადგილები გადავუნაცვლეთ და მათ შორის ჩავსვით ბარბარე. რადგან კომპიუტერული პროგრამაა, React-ს არ შეუძლია ჩვენი განზრახვების მიხვედრა, ამიტომ სიის ელემენტების ერთმანეთისაგან გასარჩევად, ყოველ ელემენტს უნდა განვუსაზღვროთ (უნიკალური) *key* (გასაღები) თვისება. ამ შემთხვევაში, ერთ-ერთი ვარიანტია სტრიქონების -- `დემნა`, `ზურა`, `ბარბარე` -- გამოყენება. თუკი მონაცემები მონაცემთა ბაზიდან მოგვაქვს, შეგვიძლია, გასაღებებად უნიკალური იდენტიფიკატორები (id) გამოვიყენოთ.


```html
<li key={user.id}>{user.name}: {user.taskCount} დარჩენილი სამუშაო</li>
```

როცა სიის ხელახალი ასახვა ხდება, React იღებს სიის ყოველი ელემენტის გასაღებს და ადარებს უწინდელი სიის ელემენტების გასაღებებს. თუ მიმდინარე სიაში არის ელემენტი გასაღებით, როგორიც წინაში არ არსებობდა, - React ქმნის ახალ კომპონენტს. თუ მიმდინარე სიაში არ არის ელემენტი გასაღებით, როგორიც იყო წინაში, - React ანადგურებს წინა კომპონენტს. თუ ორი გასაღები ემთხვევა, მოხდება შესაბამისი კომპონენტის გადაადგილება. React-ში გასაღებები მუშაობენ როგორც კომპონენტთა იდენტიფიკატორები, რაც React-ს ხელახლა ასახვებს შორის მდგომარეობის შენარჩუნებაში ეხმარება. თუ კომპონენტის გასაღები შეიცვლება, მოხდება ამ კომპონენტის განადგურება და ხელახლა შექმნა - ახალი მდგომარეობით.

React-ში `key` არის განსაკუთრებული, რეზერვირებული თვისება (`ref`-ის მსგავსად, რომელიც შედარებით სიღრმისეული ფუნქციონალის ნაწილია). როდესაც ელემენტი იქმნება, React იღებს `key` თვისებას და ინახავს მას უშუალოდ დაბრუნებულ ელემენტში. მიუხედავად იმისა, რომ `key` თითქოს `props`-ს ეკუთვნის, მასზე წვდომა შეუძლებელია `this.props.key` ჩანაწერით. React ავტომატურად იყენებს `key`-ს იმის დასადგენად, თუ რომელი კომპონენტების განახლება უნდა მოხდეს. კომპონენტს არ შეუძლია, მისწვდეს საკუთარ `key`-ს.

**ყოველთვის, როდესაც დინამიურ სიებს ქმნით, რეკომენდებულია გასაღებების სწორად შერჩევა.** თუ არ გაქვთ შესაბამასი გასაღები, განიხილეთ თქვენი მონაცემების რესტრუქტურირება ისე, რომ გქონდეთ.

თუ გასაღებს არ განვსაზღვრავთ, React დაგვიბრუნებს გაფრთხილებას, და გასაღების ნაგულისხმევ მნიშვნელობად მასივის ინდექსს გამოიყენებს. მასივის ინდექსის გასაღებად გამოყენება გამოიწვევს პრობლემებს, როდესაც სიის ელემენტების ხელახლა დალაგებას, ან ელემენტების შეტანა/ამოშლას ვეცდებით. `key={i}`-ის გადაწოდება ცალსახად გააქრობს გაფრთხილებას, მაგრამ, მასივის ინდექსებთან დაკავშირებით იქნება იგივე პრობლემები, ამიტომ, უმეტეს შემთხვევაში ამის გაკეთება არ არის რეკომენდებული.

არ არის აუცილებელი გასაღებების გლობალური უნიკალურობა. მათი უნიკალურობა მხოლოდ მეზობელ კომპონენტებს შორის არის საჭირო.


### დროში მოგზაურობის სისრულეში მოყვანა {#implementing-time-travel}

თამაშის (ჯვრები და ნულები) ისტორიაში, ყოველ შესრულებულ სვლას აქვს უნიკალური ID, - სვლის რიგითი ნომერი. არასოდეს ხდება სვლების ხელახლა დალაგება, ამოშლა, ან ახლის შეტანა სიის შუაში, ასე რომ, სვლის ინდექსის, როგორც გასაღების გამოყენება საიმედოა.

`Game` კომპონენტის `render` მეთოდში შეგვიძლია დავამატოთ გასაღები, როგორც: `<li key={move}>`, და React-ის გაფრთხილება გასაღებების შესახებ გაქრება (კონსოლიდან):

```js{6}
    const moves = history.map((step, move) => {
      const desc = move ?
        'Go to move #' + move :
        'Go to game start';
      return (
        <li key={move}>
          <button onClick={() => this.jumpTo(move)}>{desc}</button>
        </li>
      );
    });
```

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/PmmXRE?editors=0010)**

სიაში მოცემულთაგან ნებისმიერ ღილაკზე დაწკაპუნება გამოიწვევს შეცდომას, რადგან `jumpTo` მეთოდი არ არის განსაზღვრული. სანამ `jumpTo`-ს შევქმნიდეთ, მოდით, `Game` კომპონენტის მდგომარეობის ამსახველ ობიექტში ჩავამატოთ `stepNumber` - იმის დასადგენად, თუ რომელ სვლაზე ვიმყოფებით ამჟამად.

პირველ რიგში, `Game`-ის `constructor`-ში, საწყისი მდგომარეობის ამსახველ ობიექტში, ჩავამატოთ `stepNumber: 0`:

```js{8}
class Game extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      history: [{
        squares: Array(9).fill(null),
      }],
      stepNumber: 0,
      xIsNext: true,
    };
  }
```

ამის შემდეგ, `stepNumber`-ის მნიშვნელობის განახლებისათვის, `Game`-ში შევქმნათ `jumpTo` მეთოდი. ასევე, როცა რიცხვი, რომელსაც `stepNumber` უნდა გაუტოლდეს იქნება - ლუწი, `xIsNext`-ის მნიშვნელობა უნდა გახდეს - `true`:

```javascript{5-10}
  handleClick(i) {
    // ეს მეთოდი არ შეცვლილა
  }

  jumpTo(step) {
    this.setState({
      stepNumber: step,
      xIsNext: (step % 2) === 0,
    });
  }

  render() {
    // ეს მეთოდი არ შეცვლილა
  }
```

`Game`-ის `handleClick` მეთოდში, რომლის გამოძახებაც უჯრედზე დაწკაპუნებისას ხდება, ახლა რამდენიმე ცვლილებას შევიტანთ.

ჩვენს მიერ დამატებული `stepNumber` ასახავს სვლას, რომელსაც მომხმარებელი ამჟამად არის ნაჩვენები. ახალი სვლის განხორციელების შემდეგ, საჭიროა `stepNumber`-ის განახლება `stepNumber: history.length`-ის, როგორც `this.setState`-ის არგუმენტის ნაწილის გამოყენებით. ამით თავიდან ავირიდებთ გაჭედვას ძველი სვლის ჩვენებაზე, როდესაც ახალი სვლა უკვე გაკეთებულია.

ასევე, `this.state.history` უნდა ჩავანაცვლოთ - `this.state.history.slice(0, this.state.stepNumber + 1)`-ით. ეს იძლევა იმის გარანტიას, რომ, თუ ჩვენ „დროში უკან გადავხტებით“, და ამ მდგომარეობიდან გავაკეთებთ ახალ სვლას, სრულად წაიშლება „მომავლის“ შეუსაბამო ისტორია.

```javascript{2,13}
  handleClick(i) {
    const history = this.state.history.slice(0, this.state.stepNumber + 1);
    const current = history[history.length - 1];
    const squares = current.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? 'X' : 'O';
    this.setState({
      history: history.concat([{
        squares: squares
      }]),
      stepNumber: history.length,
      xIsNext: !this.state.xIsNext,
    });
  }
```

დაბოლოს, უნდა გადავაკეთოთ `Game` კომპონენტის `render` მეთოდი ისე, რომ უკანასკნელი სვლის ნაცვლად, აისახოს `stepNumber`-ის მიმდინარე მნიშვნელობის შესაბამისი სვლა:

```javascript{3}
  render() {
    const history = this.state.history;
    const current = history[this.state.stepNumber];
    const winner = calculateWinner(current.squares);

    // დანარჩენი კოდი არ შეცვლილა
```

თუ თამაშის ისტორიის რომელიმე სვლაზე დავაწკაპუნებთ, დაფა დაუყოვნებლივ განახლდება და გვაჩვენებს, თუ როგორ გამოიყურებოდა იგი ამ სვლის გაკეთების შემდეგ.

**[იხილეთ სრული კოდი ამჟამინდელი მდგომარეობით](https://codepen.io/gaearon/pen/gWWZgR?editors=0010)**

### შეჯამება {#wrapping-up}

გილოცავთ! თქვენ შექმენით თამაში - ჯვრები და ნულები, რომელიც:

* საშუალებას გაძლევთ, ითამაშოთ - ჯვრები და ნულები,
* ადგენს გამარჯვებულს,
* ინახავს თამაშის ისტორიას,
* მოთამაშეებს საშუალებას აძლევს, იხილონ თამაშის ისტორია და დაბრუნდნენ წინა სვლებზე.

მშვენიერი ნამუშევარია! ვიმედოვნებთ, რომ ახლა მშვენივრად გესმით, თუ როგორ მუშაობს React.

იხილეთ თამაშის დასრულებული ვერსია აქ: **[საბოლოო შედეგი](https://codepen.io/gaearon/pen/gWWZgR?editors=0010)**.

თუ გაქვთ დამატებით დრო, ან გსურთ, გამოსცადოთ თქვენი ახლად შეძენილი უნარები React-ში, ქვემოთ მოცემულია თამაში - ჯვრები და ნულების გაუმჯობესების რამდენიმე იდეა (დალაგებულია სირთულის ზრდადობის მიხედვით):

1. სვლების ისტორიის სიაში წარმოადგინეთ ყოველი სვლის პოზიცია ფორმატში (სვეტი, სტრიქონი).
2. სვლების სიაში მონიშნეთ (გამოკვეთეთ) არჩეული ელემენტი.
3. ხელახლა დაწერეთ `Board` კომპონენტი ისე, რომ უჯრედები - ხელით ჩაწერის ნაცვლად, - დაგენერირდეს ციკლების გამოყენებით.
4. დაამატეთ გადამრთველი, რომელიც საშუალებას მოგცემთ, დაალაგოთ სვლები აღმავალი ან დაღმავალი მიმდევრობით.
5. როცა ვიღაც გაიმარჯვებს, მონიშნეთ ის სამი უჯრედი, რომელმაც გამოიწვია მოგება.
6. როცა არავინ გაიმარჯვებს, გამოჩნდეს შეტყობინება, რომელიც იუწყება, რომ თამაში ფრედ დამთავრდა.

ამ სახელმძღვანელოში ჩვენ შევეხეთ React-ის ისეთ ცნებებს, როგორებიცაა ელემენტები, კომპონენტები, თვისებები (props) და მდგომარეობა (state). ამ თემების შესახებ უფრო დეტალური განმარტებების მისაღებად, იხილეთ [დოკუმენტაციის დანარჩენი ნაწილი](/docs/hello-world.html). კომპონენტების შექმნასთან დაკავშირებით დეტალური ინფორმაციის მისაღებად, იხილეთ [`React.Component`-ის API სქოლიო](/docs/react-component.html).
